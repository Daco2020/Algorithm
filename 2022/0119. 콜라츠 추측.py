'''
문제 설명
1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 
모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.

1-1. 입력된 수가 짝수라면 2로 나눕니다. 
1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.
2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.


예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 
위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 
단, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.


제한 사항
입력된 수, num은 1 이상 8000000 미만인 정수입니다.


입출력 예 설명
입출력 예 #1
문제의 설명과 같습니다.

입출력 예 #2
16 -> 8 -> 4 -> 2 -> 1 이되어 총 4번만에 1이 됩니다.

입출력 예 #3
626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.


해결 방법
1. 인풋 숫자의 홀짝을 구한다.
2. 짝이면 2를 나누고 카운팅을 한다.
3. 홀이면 3을 곱하고 1을 더한 후 카운팅을 한다.
4. 결과가 1이 될 때까지 반복한다.
5. 결과가 1이 나오면 카운팅을 반환한다.
6. 카운팅이 500을 넘어서면 -1 을 반환한다.
'''

import time


def solution(num):
    cnt = 0

    while not num == 1:

        if num % 2 == 0:
            num = num / 2
        else:
            num = num * 3 + 1

        cnt += 1

    if cnt >= 500:
        cnt = -1

    return cnt


def solution(num):
    cnt = 0

    while not num == 1:

        num = num / 2 if num % 2 == 0 else num * 3 + 1

        cnt += 1

    return cnt if cnt < 500 else -1


# 일반 코드와 삼항연산자의 효율을 비교해보았지만 큰 차이가 없음..
start = time.time()
print(solution(500000)*10000000000000000)
end = time.time()
print(start, end)
print(f"걸린 시간 : {end-start}")


'''
두 풀이 모두 내용은 같으나 표현만 다르게 한 것이다.

둘의 효율 차이를 알고 싶어서 따로 테스트를 해보았는데 유의미한 차이를 확인하지 못했다. 
결국 스타일과 가독성에 따라 선택하면 될 것 같다. 
삼항연산자의 경우 예전에는 가독성이 좋아보이지 않았는데 
이제와서는 익숙해져서인지 가독성도 나쁘지 않은 것 같다. 

다른 사람들의 풀이를 보니 retrun을 여러번 사용하는 식으로 푼 경우가 있는데 
되도록이면 return은 마지막에 한 번만 적는게 좋을 것 같다. 
반환 값을 변수로 관리하다가 최종적으로 return 하는 것이 
나중에 수정도 용이하고 코드도 더 깔끔할 것 같다.


'''
