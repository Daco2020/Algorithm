### 문제 설명

정수를 저장한 배열, arr에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를 들어 arr이 \[4,3,2,1\]인 경우는 \[4,3,2\]를 리턴하고, \[10\] 면 \[-1\]을 리턴합니다.

### 제한 조건

arr은 길이 1 이상인 배열입니다.  
인덱스 i, j에 대해 i ≠ j이면 arr\[i\] ≠ arr\[j\] 입니다.

**추가조건 >>> if는 사용하지 않습니다.**

### 해결 방법

1. 리스트에서 최소 값을 구한다.  
2. 구한 최소 값을 리스트에서 지운다.  
3. 논리 연산자를 활용하여 최소 값을 지운 리스트를 반환한다.  
4. 만약 리스트가 비어있다면 \[-1\]을 반환한다.

  
\* or은 첫 번째가 참이면 첫 번째 값을, 두 번째가 참이면 두 번째 값을 반환하기 때문에 if를 사용하지 않고 값을 반환할 수 있다.

```
def solution(arr):
    arr.remove(min(arr))
    return arr or [-1]
```

그냥 풀면 너무 쉬운 것 같아서 어떻게 풀어볼까 고민하다 if를 사용하지 않기로 했다. 기존 다른 사람들의 풀이는 문제가 개편되기 전이기 때문에 \[-1\] 이 아닌 \[\] 빈 리스트만 반환하면 되었지만 문제가 개편되면서 \[\]는 \[-1\]로 바꾸어 반환해야 했다.

if 말고 어떻게 반환하면 좋을까 생각해보다 사전 스터디 때 배워서 공유했던 논리 연산자의 특성을 이용해 보기로 했다. (언제 써먹나 했는데 드디어 써먹는구나!)

and는 첫 번째 값이 'True', 두 번째 값이 'True' 면 두 번째 값을 반환한다. (모두 확인하고 가장 마지막인 값)

or 은 첫 번째 값이 'True' 면 두 번째 값을 보지 않고 첫 번째 값을 반환한다. (True만 확인되면 곧바로 반환)

만약 첫 번째 값이 'False', 두 번째 값이 'True' 면 두 번째 값을 반환한다. (위와 동일한 원리)

이러한 특성을 활용하면 if 없이도 분기 처리를 할 수 있다!