### 문제 설명

단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 

단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.

### 제한 사항

s는 길이가 1 이상, 100이하인 스트링입니다.

### 해결 방법

1\. s의 길이를 구한다.

2\. 구한 길이를 2로 나눈 값과 나머지를 각각 구한다.

3\. 나머지가 0이라면 짝수라는 뜻이므로 가운데 두 글자를 반환한다.

4\. 나머지가 1이라면 홀수라는 뜻이므로 가운데 한 글자를 반환한다.

5\. 값을 구할 때는 나눈 값을 인덱스로 활용해 구한다.

```
def solution(s):
    s_num = len(s)
    key, index = s_num % 2, s_num // 2
    
    answer_dict = { 0 : s[index-1:index+1], 1 : s[index] }
    answer = answer_dict[key]
    
    return answer
```

if나 for를 사용하지 않기 위해 딕셔너리로 접근했다. (여기에 사용할만한 내장함수는 생각나지 않았다.)

코드 줄 수야 줄일 수 있었지만 그보다는 연산을 적게하고 변수명을 명확하게 만들어 가독성을 높이는데 고민했다.

s의 길이를 구한 값은 한 번만 연산하기 위해 변수에 할당했고,

딕셔너리를 사용할 것이기 때문에 키로 사용할 나머지 값과 인덱스로 사용할 나눈 값을 각각 변수로 할당했다.

딕셔너리를 만들어 홀수, 짝수에 대한 키를 설정하고 각각 해당되는 값을 지정하였다.

사실 이 코드도 한 줄로 만들 수 있다.

```
def solution(s): 
    return {0:s[len(s)//2-1:len(s)//2+1], 1:s[len(s)//2]}[len(s) % 2]
```

  
이 코드는 위에 코드와 동일하다.

하지만 위에 코드와 비교해보면 코드를 이해하는데 시간이 걸린다.

그리고 len(s)와 같은 동일한 연산이 4번이나 이루어지고 있다.

---

그럼 나보다 잘 푼 코드도 살펴보자

```
def string_middle(str):
    return str[(len(str)-1)//2:len(str)//2+1]
```

딕셔너리까지 갈 필요없이 슬라이싱을 활용하여 간결하게 풀어냈다.

하지만 이 코드에도 len(str)은 두 번 실행되고 있다. 

그리고 첫 눈에 보기에 읽기가 어렵다.

이 코드를 아래 코드처럼 바꾸어 보았다.

```
def solution(s): 
    s_len = len(s)
    answer = s[ (s_len-1)//2 : s_len//2+1 ]
    return answer
```

len(s)의 중복을 막기위해 변수에 할당하고 

슬라이싱을 명확히 보여주기 위해 띄어쓰기로 연산을 구분해주었다.

이제 이해하기도 쉽고 중복되는 연산도 없어보인다!

코드를 작성할 때 효율성과 가독성 모두 챙기는 습관을 들여야겠다.

---

출처: 프로그래머스 코딩 테스트 연습, [https://programmers.co.kr/learn/challenges](https://programmers.co.kr/learn/challenges)